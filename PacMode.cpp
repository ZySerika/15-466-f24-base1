#include "PacMode.hpp"

//for the GL_ERRORS() macro:
#include "gl_errors.hpp"

//for glm::value_ptr() :
#include <glm/gtc/type_ptr.hpp>
#include <fstream>

#include "Load.hpp"

#include "data_path.hpp"
#include "read_write_chunk.hpp"

#include <random>

// Load usage is from https://15466.courses.cs.cmu.edu/lesson/assets
Load <PacMode::Board> board(LoadTagDefault, []() -> PacMode::Board const * {
	return new PacMode::Board(data_path("board.bin"));
});

// load player sprite from car_sprite.bin
Load <PPU466::Tile> player_tile(LoadTagDefault, []() -> PPU466::Tile const * {
	std::ifstream file("car_sprite_tile.bin", std::ios::binary);
    if (!file) {
        throw std::runtime_error("Failed to open board file car sprite");
    }
	std::vector<PPU466::Tile> tile;
	read_chunk<PPU466::Tile>(file, "TILE", &tile);
	return new PPU466::Tile(tile[0]);
});

Load <PPU466::Palette> player_palette(LoadTagDefault, []() -> PPU466::Palette const * {
	std::ifstream file("car_sprite.bin", std::ios::binary);
	if (!file) {
		throw std::runtime_error("Failed to open board file car sprite");
	}
	std::vector<PPU466::Palette> palette;
	read_chunk<PPU466::Palette>(file, "PALT", &palette);
	return new PPU466::Palette(palette[0]);
});

Load <std::vector<uint16_t>> background(LoadTagDefault, []() -> std::vector<uint16_t> const * {
	std::ifstream file("background.bin", std::ios::binary);
	if (!file) {
		throw std::runtime_error("Failed to open board file background");
	}
	std::vector<uint16_t> *bg = new std::vector<uint16_t>();
	read_chunk<uint16_t>(file, "BGRA", bg);
	return bg;
});

PacMode::Board::Board(std::string const &path) {
	std::ifstream file(path, std::ios::binary);
    if (!file) {
        throw std::runtime_error("Failed to open board file: " + path);
    }
	std::vector<Grid> flat_board_data;
	read_chunk<Grid>(file, "BRDD", &flat_board_data);
	std::vector<std::vector<Grid>> _board;
	_board.resize(28, std::vector<Grid>(28));
	for (size_t y = 0; y < 28; ++y) {
		for (size_t x = 0; x < 28; ++x) {
			_board[y][x] = flat_board_data[y * 28 + x]; 
		}
	}
	board = _board;
	size = glm::uvec2(28, 28);
}

PacMode::PacMode() {
	//TODO:
	// you *must* use an asset pipeline of some sort to generate tiles.
	// don't hardcode them like this!
	// or, at least, if you do hardcode them like this,
	//  make yourself a script that spits out the code that you paste in here
	//   and check that script into your repository.

	// A workaround solution for tech debt due to bad typing. Fix from OpenAI
	gb = const_cast<PacMode::Board*>(&*board);
	
	player_dir = 0;
	player_at = glm::uvec2(0, 0);
	palletcount = 0;
	iswinlose = 0;
	for (uint32_t x = 0; x < gb->size.x; ++x) {
		for (uint32_t y = 0; y < gb->size.y; ++y) {
			if (gb->board[x][y].pallet > 0) {
				palletcount += 1;
			}
		}
	}

	ppu.tile_table[32].bit0 = player_tile->bit0;
	ppu.tile_table[32].bit1 = player_tile->bit1;

	std::array<uint8_t, 8> mask_1 = {
		0b01111110,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111110,
	};
	std::array<uint8_t, 8> mask_2 = {
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	};
	// green 
	ppu.tile_table[33].bit0 = mask_1;
	ppu.tile_table[33].bit1 = mask_2;
	// yellow
	ppu.tile_table[34].bit0 = mask_1;
	ppu.tile_table[34].bit1 = mask_1;

	// red
	ppu.tile_table[35].bit0 = mask_2;
	ppu.tile_table[35].bit1 = mask_1;


	ppu.palette_table[0] = *player_palette;

	// Colors generated by chatGPT, I think this doesn't need a pipeline since it's just fixed colors
	PPU466::Palette green_red_yellow_transparent_palette = {
    glm::u8vec4(0x00, 0x00, 0x00, 0x00), // Color 0: Fully transparent (RGBA)
    glm::u8vec4(0x00, 0xFF, 0x00, 0xFF), // Color 1: Green (RGBA)
    glm::u8vec4(0xFF, 0x00, 0x00, 0xFF), // Color 2: Red (RGBA)
    glm::u8vec4(0xFF, 0xFF, 0x00, 0xFF)  // Color 3: Yellow (RGBA)
	};

	ppu.palette_table[1] = green_red_yellow_transparent_palette;
	
	// Colors generated by chatGPT
	PPU466::Palette grey_palette = {
    glm::u8vec4(0x00, 0x00, 0x00, 0x00), // Color 0: Fully transparent (RGBA)
    glm::u8vec4(0x55, 0x55, 0x55, 0xFF), // Color 1: Dark grey (85, 85, 85) (RGBA)
    glm::u8vec4(0xAA, 0xAA, 0xAA, 0xFF), // Color 2: Light grey (170, 170, 170) (RGBA)
    glm::u8vec4(0xFF, 0xFF, 0xFF, 0xFF)  // Color 3: White (optional or as a bright grey) (RGBA)
	};
	ppu.palette_table[2] = grey_palette;
};


PacMode::~PacMode() {
	delete gb;
}

bool PacMode::handle_event(SDL_Event const &evt, glm::uvec2 const &window_size) {

	if (evt.type == SDL_KEYDOWN) {
		if (evt.key.keysym.sym == SDLK_LEFT) {
			button_pressed = 3;
			return true;
		} else if (evt.key.keysym.sym == SDLK_RIGHT) {
			button_pressed = 1;
			return true;
		} else if (evt.key.keysym.sym == SDLK_UP) {
			button_pressed = 0;
			return true;
		} else if (evt.key.keysym.sym == SDLK_DOWN) {
			button_pressed = 2;
			return true;
		}
	} else if (evt.type == SDL_KEYUP) {
		// do nothing
	}

	return false;
}

// Returns true if there is a wall in the direction dir from pos
bool PacMode::has_wall(glm::uvec2 pos, uint8_t dir) {
	// Should not happen: pos is outside the board
	if (pos.x < 0 || pos.x >= board->size.x || pos.y < 0 || pos.y >= board->size.y) {
		return true;
	}
	// pos is on a wall
	if(gb->board[pos.x][pos.y].is_wall) {
		return true;
	}
	// Check if there is a wall in the direction dir
	if (dir == 0) {
		if (pos.y + 1 >= board->size.y) {
			return true;
		}
		return gb->board[pos.x][pos.y + 1].is_wall;
	} else if (dir == 2) {
		if (pos.y - 1 < 0) {
			return true;
		}
		return gb->board[pos.x][pos.y - 1].is_wall;
	} else if (dir == 3) {
		if (pos.x - 1 < 0) {
			return true;
		}
		return gb->board[pos.x - 1][pos.y].is_wall;
	} else if (dir == 1) {
		if (pos.x + 1 >= board->size.x) {
			return true;
		}
		return gb->board[pos.x + 1][pos.y].is_wall;
	}
	return false;
}


void PacMode::tick() {
	// process input; cannot go behind and across walls
	if(button_pressed == 0) {
		if(player_dir != 2 && !has_wall(player_at, 0)) {
			player_dir = 0;
		}
	} else if(button_pressed == 1) {
		if(player_dir != 3 && !has_wall(player_at, 1)) {
			player_dir = 1;
		}
	} else if(button_pressed == 2) {
		if(player_dir != 0 && !has_wall(player_at, 2)) {
			player_dir = 2;
		}
	} else if(button_pressed == 3) {
		if(player_dir != 1 && !has_wall(player_at, 3)) {
			player_dir = 3;
		}
	} else if(button_pressed == 4) {
		// do nothing
	} else {
		// should not happen
	}

	// player moves in its current direction unless it hits a wall
	uint8_t prevdir = player_dir;
	while(has_wall(player_at, player_dir)) {
		player_dir = (player_dir + 1) % 4;
		if(player_dir == prevdir) {
			// player is stuck
			break;
		}
	}

	// move forward
	switch (player_dir) {
		case 0:
			player_at.y += 1;
			break;
		case 1:
			player_at.x += 1;
			break;
		case 2:
			player_at.y -= 1;
			break;
		case 3:
			player_at.x -= 1;
			break;
		default:
			// should not happen
			break;
	}

	// eat pallet and check win/lose
	if (gb->board[player_at.x][player_at.y].pallet == 1) {
		gb->board[player_at.x][player_at.y].pallet = 0;
		palletcount -= 1;
		if(palletcount == 0) {
			iswinlose = 1;
		}
	} else if (gb->board[player_at.x][player_at.y].pallet == 2) {
		gb->board[player_at.x][player_at.y].pallet = 0;
		palletcount -= 1;
		if(palletcount == 0) {
			iswinlose = 1;
		}
	} else if (gb->board[player_at.x][player_at.y].pallet == 3) {
		gb->board[player_at.x][player_at.y].pallet = 0;
		iswinlose = 2;
	}

	// for each pallet, 25% chance to change to yellow and then red
	for (uint32_t x = 0; x < gb->size.x; ++x) {
		for (uint32_t y = 0; y < gb->size.y; ++y) {
			if (gb->board[x][y].pallet > 0) {
				if (rand() % 4 == 0) {
					gb->board[x][y].pallet++;
				}
			}

		}
	}


}

void PacMode::update(float elapsed) {

	if(iswinlose != 0) {
		return;
	}
	// from https://15466.courses.cs.cmu.edu/lesson/timing
	tick_acc += elapsed;
	while (tick_acc > Tick) {
		tick_acc -= Tick;
		tick();
	}

	//reset button press
	button_pressed = 4;
}

void PacMode::draw(glm::uvec2 const &drawable_size) {
	//--- set ppu state based on game state ---

	ppu.background_color = glm::u8vec3(0x55, 0x55, 0x55);

	std::copy(background->begin(), background->end(), ppu.background.begin());
	int playerxnormalized = player_at.x*8 + 2*8;
	int playerynormalized = player_at.y*8 + 8;
	//player sprite:
	ppu.sprites[0].x = int8_t(playerxnormalized);
	ppu.sprites[0].y = int8_t(playerynormalized);
	ppu.sprites[0].index = 32;
	ppu.sprites[0].attributes = 0;
	
	uint32_t spriteind = 1;
	//some other misc sprites:
	for(uint32_t x = 0; x < gb->size.x; ++x) {
		for(uint32_t y = 0; y < gb->size.y; ++y) {
			if(gb->board[x][y].pallet > 0) {
				int spxnormalized = x*8 + 2*8;
				int spynormalized = y*8 + 8;
				ppu.sprites[spriteind].x = int8_t(spxnormalized);
				ppu.sprites[spriteind].y = int8_t(spynormalized);
				ppu.sprites[spriteind].index = 32 + gb->board[x][y].pallet;
				ppu.sprites[spriteind].attributes = 1;
				spriteind++;
			}
		}
	}
	for (; spriteind < 63; ++spriteind) {
		ppu.sprites[spriteind].attributes |= 0x80; //'behind' bit
	}

	//--- actually draw ---
	ppu.draw(drawable_size);
}
